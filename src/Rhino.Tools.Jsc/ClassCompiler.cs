/*
 * This code is derived from rhino (http://github.com/mozilla/rhino)
 * 
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at http://mozilla.org/MPL/2.0/.
 */

#if COMPILATION
using Rhino.Optimizer;
using System;
using Rhino.Ast;

namespace Rhino.Tools.Jsc
{
	/// <summary>Generates class files from script sources.</summary>
	/// <remarks>
	/// Generates class files from script sources.
	/// since 1.5 Release 5
	/// </remarks>
	/// <author>Igor Bukanov</author>
	public class ClassCompiler
	{
		/// <summary>
		/// Construct ClassCompiler that uses the specified compiler environment
		/// when generating classes.
		/// </summary>
		/// <remarks>
		/// Construct ClassCompiler that uses the specified compiler environment
		/// when generating classes.
		/// </remarks>
		public ClassCompiler(CompilerEnvirons compilerEnv)
		{
			if (compilerEnv == null)
			{
				throw new ArgumentException();
			}
			this.compilerEnv = compilerEnv;
			this.mainMethodClassName = Codegen.DEFAULT_MAIN_METHOD_CLASS.FullName;
		}

		/// <summary>Set the class name to use for main method implementation.</summary>
		/// <remarks>
		/// Set the class name to use for main method implementation.
		/// The class must have a method matching
		/// <tt>public static void main(Script sc, String[] args)</tt>, it will be
		/// called when <tt>main(String[] args)</tt> is called in the generated
		/// class. The class name should be fully qulified name and include the
		/// package name like in <tt>org.foo.Bar<tt>.
		/// </remarks>
		public virtual void SetMainMethodClass(string className)
		{
			// XXX Should this check for a valid class name?
			mainMethodClassName = className;
		}

		/// <summary>Get the name of the class for main method implementation.</summary>
		/// <remarks>Get the name of the class for main method implementation.</remarks>
		/// <seealso cref="SetMainMethodClass">SetMainMethodClass(string)</seealso>
		public virtual string GetMainMethodClass()
		{
			return mainMethodClassName;
		}

		/// <summary>Get the compiler environment the compiler uses.</summary>
		/// <remarks>Get the compiler environment the compiler uses.</remarks>
		public virtual CompilerEnvirons GetCompilerEnv()
		{
			return compilerEnv;
		}

		/// <summary>Get the class that the generated target will extend.</summary>
		/// <remarks>Get the class that the generated target will extend.</remarks>
		public virtual Type GetTargetExtends()
		{
			return targetExtends;
		}

		/// <summary>Set the class that the generated target will extend.</summary>
		/// <remarks>Set the class that the generated target will extend.</remarks>
		/// <param name="extendsClass">the class it extends</param>
		public virtual void SetTargetExtends(Type extendsClass)
		{
			targetExtends = extendsClass;
		}

		/// <summary>Get the interfaces that the generated target will implement.</summary>
		/// <remarks>Get the interfaces that the generated target will implement.</remarks>
		public virtual Type[] GetTargetImplements()
		{
			return targetImplements == null ? null : (Type[])targetImplements.Clone();
		}

		/// <summary>Set the interfaces that the generated target will implement.</summary>
		/// <remarks>Set the interfaces that the generated target will implement.</remarks>
		/// <param name="implementsClasses">
		/// an array of Class objects, one for each
		/// interface the target will extend
		/// </param>
		public virtual void SetTargetImplements(Type[] implementsClasses)
		{
			targetImplements = implementsClasses == null ? null : (Type[])implementsClasses.Clone();
		}

		/// <summary>Build class name for a auxiliary class generated by compiler.</summary>
		/// <remarks>
		/// Build class name for a auxiliary class generated by compiler.
		/// If the compiler needs to generate extra classes beyond the main class,
		/// it will call this function to build the auxiliary class name.
		/// The default implementation simply appends auxMarker to mainClassName
		/// but this can be overridden.
		/// </remarks>
		protected internal virtual string MakeAuxiliaryClassName(string mainClassName, string auxMarker)
		{
			return mainClassName + auxMarker;
		}

		/// <summary>Compile JavaScript source into one or more Java class files.</summary>
		/// <remarks>
		/// Compile JavaScript source into one or more Java class files.
		/// The first compiled class will have name mainClassName.
		/// If the results of
		/// <see cref="GetTargetExtends()">GetTargetExtends()</see>
		/// or
		/// <see cref="GetTargetImplements()">GetTargetImplements()</see>
		/// are not null, then the first compiled
		/// class will extend the specified super class and implement
		/// specified interfaces.
		/// </remarks>
		/// <returns>
		/// array where elements with even indexes specifies class name
		/// and the following odd index gives class file body as byte[]
		/// array. The initial element of the array always holds
		/// mainClassName and array[1] holds its byte code.
		/// </returns>
		public virtual Tuple<string, Type>[] CompileToClassFiles(string source, string sourceLocation, int lineno, string mainClassName)
		{
			Parser p = new Parser(compilerEnv);
			AstRoot ast = p.Parse(source, sourceLocation, lineno);
			IRFactory irf = new IRFactory(compilerEnv);
			ScriptNode tree = irf.TransformTree(ast);
			// release reference to original parse tree & parser
			Type superClass = GetTargetExtends();
			Type[] interfaces = GetTargetImplements();
			bool isPrimary = (interfaces == null && superClass == null);
			string scriptClassName = isPrimary
				? mainClassName
				: MakeAuxiliaryClassName(mainClassName, "1");
			Codegen codegen = new Codegen();
			codegen.SetMainMethodClass(mainMethodClassName);
			Type scriptClassBytes = codegen.CompileToClassFile(compilerEnv, scriptClassName, tree, tree.GetEncodedSource(), false);
			if (isPrimary)
			{
				return new[] { Tuple.Create(scriptClassName, scriptClassBytes) };
			}
			int functionCount = tree.GetFunctionCount();
			ObjToIntMap functionNames = new ObjToIntMap(functionCount);
			for (int i = 0; i < functionCount; i++)
			{
				FunctionNode ofn = tree.GetFunctionNode(i);
				string name = ofn.GetName();
				if (!string.IsNullOrEmpty(name))
				{
					functionNames.Put(name, ofn.GetParamCount());
				}
			}
			if (superClass == null)
			{
				superClass = ScriptRuntime.ObjectClass;
			}
			Type mainClassBytes = JavaAdapter.CreateAdapterCode(functionNames, mainClassName, superClass, interfaces, scriptClassBytes);
			return new[] { Tuple.Create(mainClassName, mainClassBytes), Tuple.Create(scriptClassName, scriptClassBytes) };
		}

		private string mainMethodClassName;

		private CompilerEnvirons compilerEnv;

		private Type targetExtends;

		private Type[] targetImplements;
	}
}
#endif
