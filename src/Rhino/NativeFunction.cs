/*
 * This code is derived from rhino (http://github.com/mozilla/rhino)
 * 
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at http://mozilla.org/MPL/2.0/.
 */

using Rhino;
using Rhino.Debug;
using Sharpen;

namespace Rhino
{
	/// <summary>This class implements the Function native object.</summary>
	/// <remarks>
	/// This class implements the Function native object.
	/// See ECMA 15.3.
	/// </remarks>
	/// <author>Norris Boyd</author>
	[System.Serializable]
	public abstract class NativeFunction : BaseFunction
	{
		public void InitScriptFunction(Context cx, Scriptable scope)
		{
			ScriptRuntime.SetFunctionProtoAndParent(this, scope);
		}

		/// <param name="indent">How much to indent the decompiled result</param>
		/// <param name="flags">Flags specifying format of decompilation output</param>
		internal sealed override string Decompile(int indent, int flags)
		{
			string encodedSource = GetEncodedSource();
			if (encodedSource == null)
			{
				return base.Decompile(indent, flags);
			}
			else
			{
				UintMap properties = new UintMap(1);
				properties.Put(Decompiler.INITIAL_INDENT_PROP, indent);
				return Decompiler.Decompile(encodedSource, flags, properties);
			}
		}

		public override int Length
		{
			get
			{
				int paramCount = GetParamCount();
				if (GetLanguageVersion() != LanguageVersion.VERSION_1_2)
				{
					return paramCount;
				}
				Context cx = Context.GetContext();
				NativeCall activation = ScriptRuntime.FindFunctionActivation(cx, this);
				if (activation == null)
				{
					return paramCount;
				}
				return activation.originalArgs.Length;
			}
		}

		public override int Arity
		{
			get { return GetParamCount(); }
		}

		/// <summary>Get encoded source string.</summary>
		/// <remarks>Get encoded source string.</remarks>
		public virtual string GetEncodedSource()
		{
			return null;
		}

		public virtual DebuggableScript GetDebuggableView()
		{
			return null;
		}

		/// <summary>Resume execution of a suspended generator.</summary>
		/// <remarks>Resume execution of a suspended generator.</remarks>
		/// <param name="cx">The current context</param>
		/// <param name="scope">Scope for the parent generator function</param>
		/// <param name="operation">The resumption operation (next, send, etc.. )</param>
		/// <param name="state">The generator state (has locals, stack, etc.)</param>
		/// <param name="value">The return value of yield (if required).</param>
		/// <returns>The next yielded value (if any)</returns>
		public virtual object ResumeGenerator(Context cx, Scriptable scope, int operation, object state, object value)
		{
			throw new EvaluatorException("ResumeGenerator() not implemented");
		}

		protected internal abstract LanguageVersion GetLanguageVersion();

		/// <summary>Get number of declared parameters.</summary>
		/// <remarks>Get number of declared parameters. It should be 0 for scripts.</remarks>
		protected internal abstract int GetParamCount();

		/// <summary>
		/// Get number of declared parameters and variables defined through var
		/// statements.
		/// </summary>
		/// <remarks>
		/// Get number of declared parameters and variables defined through var
		/// statements.
		/// </remarks>
		protected internal abstract int GetParamAndVarCount();

		/// <summary>Get parameter or variable name.</summary>
		/// <remarks>
		/// Get parameter or variable name.
		/// If <tt>index &lt;
		/// <see cref="GetParamCount()">GetParamCount()</see>
		/// </tt>, then return the name of the
		/// corresponding parameter. Otherwise return the name of variable.
		/// </remarks>
		protected internal abstract string GetParamOrVarName(int index);

		/// <summary>Get parameter or variable const-ness.</summary>
		/// <remarks>
		/// Get parameter or variable const-ness.
		/// If <tt>index &lt;
		/// <see cref="GetParamCount()">GetParamCount()</see>
		/// </tt>, then return the const-ness
		/// of the corresponding parameter. Otherwise return whether the variable is
		/// const.
		/// </remarks>
		protected internal virtual bool GetParamOrVarConst(int index)
		{
			// By default return false to preserve compatibility with existing
			// classes subclassing this class, which are mostly generated by jsc
			// from earlier Rhino versions. See Bugzilla #396117.
			return false;
		}
	}
}
